# -*- coding: utf-8 -*-
"""DL Reproducibility Challenge - Simple CNN - SVHN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ff5qS4G7cs7KEDuk7WxBHCrIyNfsVhPz
"""

# Commented out IPython magic to ensure Python compatibility.
# Execute this code block to install dependencies when running on colab
try:
    import torch
except:
    from os.path import exists
    from wheel.pep425tags import get_abbr_impl, get_impl_ver, get_abi_tag
    platform = '{}{}-{}'.format(get_abbr_impl(), get_impl_ver(), get_abi_tag())
    cuda_output = !ldconfig -p|grep cudart.so|sed -e 's/.*\.\([0-9]*\)\.\([0-9]*\)$/cu\1\2/'
    accelerator = cuda_output[0] if exists('/dev/nvidia0') else 'cpu'

    !pip install -q http://download.pytorch.org/whl/{accelerator}/torch-1.0.0-{platform}-linux_x86_64.whl torchvision

try: 
    import torchbearer
except:
    !pip install torchbearer --quiet

try:
    import livelossplot
except:        
    !pip install livelossplot --quiet
# automatically reload external modules if they change
# %load_ext autoreload
# %autoreload 2

import torch
import torch.nn.functional as F
import torchvision.transforms as transforms
import torchbearer
from torch import nn
from torch import optim
from torch.utils.data import DataLoader
from torchvision.datasets import SVHN
from torchbearer import Trial
from torchbearer.callbacks import LiveLossPlot
from torchbearer.callbacks import StepLR

class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.conv1 = nn.Conv2d(3, 32, (3, 3), padding=1)
        self.conv2 = nn.Conv2d(32, 32, (3, 3), padding=1)
        self.conv3 = nn.Conv2d(32, 64, (3, 3), padding=1)
        self.conv4 = nn.Conv2d(64, 128, (3, 3), padding=1)
        self.fc1 = nn.Linear(512, 128)
        self.fc2 = nn.Linear(128, 32)
        self.fc3 = nn.Linear(32, 10)
            
    def forward(self, x):       
        out = self.conv1(x)
        out = F.relu(out)
        out = F.max_pool2d(out, (2,2))       
        out = self.conv2(out)
        out = F.relu(out)
        out = F.max_pool2d(out, (2,2))
        out = self.conv3(out)
        out = F.relu(out)
        out = F.max_pool2d(out, (2,2))
        out = self.conv4(out)
        out = F.relu(out)
        out = F.max_pool2d(out, (2,2))
        out = F.dropout(out, 0.2, training=self.training)
        out = out.view(out.shape[0], -1)
        out = self.fc1(out)
        out = F.relu(out)
        out = self.fc2(out)
        out = F.relu(out)
        out = self.fc3(out)
        return out

# fix random seed for reproducibility
seed = 7
torch.manual_seed(seed)
torch.cuda.manual_seed(seed)
torch.backends.cudnn.deterministic = True

# convert each image to tensor format
transform = transforms.Compose([
    transforms.ToTensor()  # convert to tensor)
])

# load data
trainset = SVHN(".", split='train', download=True, transform=transform)
testset = SVHN(".", split='test', download=True, transform=transform)
valset = SVHN(".", split='extra', download=True, transform=transform)

# create data loaders
trainloader = DataLoader(trainset, batch_size=128, shuffle=True)
testloader = DataLoader(testset, batch_size=128, shuffle=True)
valloader = DataLoader(valset, batch_size=128, shuffle=True)

# build the model
model = SimpleCNN()

# define the loss function and the optimiser
loss_function = nn.CrossEntropyLoss()
live_loss_plot = LiveLossPlot(draw_once=True)
optimiser = optim.Adam(model.parameters(), lr=0.001)
scheduler = StepLR(step_size=10, gamma=0.5)

device = "cuda:0" if torch.cuda.is_available() else "cpu"
trial = Trial(model, optimiser, loss_function, callbacks=[scheduler, live_loss_plot], metrics=['loss', 'accuracy']).to(device)
trial.with_generators(trainloader, val_generator=valloader, test_generator=testloader)
history = trial.run(verbose=1, epochs=30)#

results = trial.evaluate(data_key=torchbearer.TEST_DATA)
print(results)

# build the model
model = SimpleCNN()

# define the loss function and the optimiser
loss_function = nn.CrossEntropyLoss()
live_loss_plot = LiveLossPlot(draw_once=True)
optimiser = optim.Adam(model.parameters(), lr=0.001)
scheduler = StepLR(step_size=10, gamma=0.5)

device = "cuda:0" if torch.cuda.is_available() else "cpu"
trial = Trial(model, optimiser, loss_function, callbacks=[scheduler, live_loss_plot], metrics=['loss', 'accuracy']).to(device)
trial.with_generators(trainloader, test_generator=testloader)
history = trial.run(verbose=1, epochs=30)#

results = trial.evaluate(data_key=torchbearer.TEST_DATA)
print(results)

print(history)